# -*- coding: utf-8 -*-
import pygame as pg
import math
pg.init()
clock = pg.time.Clock()  # set FPS=60 (error+2%)

# Final Constants ------------------------------------------------------------------------------------------------------
FONT14 = pg.font.SysFont('ocraextended', 14)
FONT16 = pg.font.SysFont('ocraextended', 16)
FONT18 = pg.font.SysFont('ocraextended', 18)
FONT20 = pg.font.SysFont('ocraextended', 20)
PURPLE = (109, 55, 140)
RED = (255, 89, 100)
GREEN = (119, 224, 36)
ORANGE = (251, 176, 59)
BLUE = (12, 239, 232)
WHITE = (255, 255, 255)
GRAY1 = (242, 242, 242)
GRAY2 = (230, 230, 230)
GRAY3 = (179, 179, 179)
GRAY4 = (153, 153, 153)
GRAY5 = (128, 128, 128)
BLACK = (0, 0, 0)
simulation_backg = pg.image.load('simulation_backg.png')
shooter_top = pg.image.load('shooter_top.png')
shooter = {
    45: pg.image.load('shooter_side45.png'), 50: pg.image.load('shooter_side50.png'),
    55: pg.image.load('shooter_side55.png'), 60: pg.image.load('shooter_side60.png'),
    65: pg.image.load('shooter_side65.png'), 70: pg.image.load('shooter_side70.png'),
    75: pg.image.load('shooter_side75.png'), 80: pg.image.load('shooter_side80.png'),
    85: pg.image.load('shooter_side85.png'), 90: pg.image.load('shooter_side90.png')
}
target_side = pg.image.load('target.png')
basket_side = pg.image.load('basket_side.png')
basket_top = pg.image.load('basket_top.png')
winX, winY = 1024, 768
targetX, targetY = 901, 150
shooterX, shooterY = 436, 611
radius = 74  # radius = 57.29*size (size = 1.3)
# def getRadius(size):
#     position = 0
#     teta = 0
#     while teta<=180:
#         position += size*math.sin(float(teta) / 180 * math.pi)
#         teta += 1
#     return int(position/2)

class Basket:
    def __init__(self, posiX, posiY, phase, color=GRAY2):
        self.posiZ = posiX
        self.posiX = posiY
        self.phase = phase
        self.color = color
        self.begin = self.posiZ, self.posiX
    def setTarget(self, velocity):
        self.velocity = velocity
    def draw(self, angle, speed):
        angle += self.phase
        pg.draw.line(screen, self.color, (targetX, targetY), (self.posiZ, self.posiX), 5)
        screen.blit(basket_top, (int(self.posiZ)-25, int(self.posiX)-25))
        if self.posiX >= targetY*0.6:
            pg.draw.line(screen, self.color, (targetX, shooterY), (self.posiZ, shooterY), 5)
            screen.blit(basket_side, (int(self.posiZ) - 25, 586))

        self.posiZ += 1.3 * self.velocity * speed * math.sin(float(angle) / 180 * math.pi)
        self.posiX += 1.3 * self.velocity * speed * math.cos(float(angle) / 180 * math.pi)
    def setBegin(self):
        self.posiZ, self.posiX = self.begin
bas1 = Basket(targetX - radius, targetY, 0, ORANGE)
bas2 = Basket(targetX, targetY + radius, 90)
bas3 = Basket(targetX + radius, targetY, 180)
bas4 = Basket(targetX, targetY - radius, 270)
baskets = [bas1, bas2, bas3, bas4]

class Ball:
    def __init__(self, posiX, posiY):
        self.posiZ = posiX
        self.posiY = posiY
        self.direction = []
    def setShooter(self, angle, time, distance):
        frame = time*60.0
        self.veloZ = 391.0 / frame
        self.veloY = -self.veloZ * math.tan(float(angle)/180*math.pi)
        self.begin = self.posiZ, self.posiY, self.veloZ, self.veloY
        self.accelY = 2 * -self.veloY / frame
        self.distance = distance
    def draw(self, speed):
        pg.draw.circle(screen, ORANGE, (int(self.posiZ), int(self.posiY)), 13)
        screen.blit(FONT14.render("Y: %.2f m" %((shooterY-self.posiY)*self.distance/465), True, ORANGE),
                    (int(self.posiZ+20), int(self.posiY-17)))
        screen.blit(FONT14.render("Z: %.2f m" %((self.posiZ-shooterX)*self.distance/465), True, ORANGE),
                    (int(self.posiZ+20), int(self.posiY)))

        pg.draw.circle(screen, ORANGE, (int(self.posiZ), targetY), 13 + int((shooterY-self.posiY)*.03))
        screen.blit(FONT14.render("Z: %.2f m" %((self.posiZ-shooterX)*self.distance/465), True, ORANGE),
                    (int(self.posiZ-35), targetY+25))

        self.posiZ += self.veloZ * speed
        self.posiY += self.veloY * speed
        self.veloY += self.accelY * speed
        if self.posiZ % 10 < self.veloZ:
            self.direction.append([int(self.posiZ), int(self.posiY)])
    def drawDirection(self):
        for point in self.direction:
            pg.draw.circle(screen, ORANGE, (point), 2)
            pg.draw.circle(screen, ORANGE, (point[0], targetY), 2)
    def setBegin(self):
        self.posiZ, self.posiY, self.veloZ, self.veloY = self.begin
        self.direction = []
ball = Ball(shooterX, shooterY)

def drawSolution(angle, speed, delay, total, mode_lockspeed):
    if mode_lockspeed:
        screen.blit(FONT20.render("Shoot Angle: {} deg".format(angle), True, BLACK), (30, 340))
        screen.blit(FONT14.render("Shoot Speed: {} rpm".format(speed), True, GRAY5), (30, 370))
    else:
        screen.blit(FONT20.render("Shoot Speed: {} rpm".format(speed), True, BLACK), (30, 340))
        screen.blit(FONT14.render("Shoot Angle: {} deg".format(angle), True, GRAY5), (30, 370))

    screen.blit(FONT20.render("Shoot Delay: %i ms" %(delay*1000), True, BLACK), (30, 410))
    screen.blit(FONT14.render("Total: %i ms" %(total*1000), True, GRAY5), (30, 440))

def drawTimer(loop, delay, in_air):
    n = loop/(delay*60 + in_air*60)
    screen.blit(FONT16.render("Timer:", True, GRAY2), (440, 724))
    screen.blit(FONT16.render("%.0f ms" %(n*(delay+in_air)*1000), True, GRAY2), (505 + n*300, 724))

    pg.draw.line(screen, ORANGE, (500, 733), (500 + n*300, 733), 5)
    if loop <= delay*60:
        pg.draw.line(screen, BLUE, (500, 733), (500 + n*300, 733), 5)
    else:
        pg.draw.line(screen, BLUE, (500, 733), (500 + delay/(delay+in_air)*300, 733), 5)
        screen.blit(FONT14.render("%.0f ms" %(delay*1000), True, BLUE), (445 + delay/(delay+in_air)*300, 712))
        if n == 1: screen.blit(FONT14.render("%.0f ms" %(n*in_air*1000), True, ORANGE), (745, 712))

# Input ----------------------------------------------------------------------------------------------------------------
target_distance = 2  # meter
target_velocity = 20.0  # rpm
shoot_angle = 60  # degree
shoot_speed = 1000  # rpm
time_delay = 1.0  # second
time_in_air = 2.0   # second
speed_display = 0.5
mode = True

for basket in baskets:
    basket.setTarget(target_velocity/10)
ball.setShooter(shoot_angle, time_in_air, target_distance)

angle = 0 ; loop = 0 ; count = 0
screen = pg.display.set_mode((winX, winY))
while True:  # Run -----------------------------------------------------------------------------------------------------
    screen.blit(simulation_backg, (0, 0))
    screen.blit(target_side, (851, 606))
    if loop >= (time_delay+time_in_air)*60:
        print ("{} ms per loop / {} ms in fact".format(pg.time.get_ticks()-count, int(time_delay+time_in_air)*1000))
        pg.time.delay(300)
        ball.setBegin()
        for basket in baskets:
            basket.setBegin()
        angle = 0
        loop = 0
        count = pg.time.get_ticks()
    loop += speed_display

    drawSolution(shoot_angle, shoot_speed, time_delay, time_delay+time_in_air, mode)
    drawTimer(loop, time_delay, time_in_air)

    for basket in baskets:
        basket.draw(angle, speed_display)
    pg.draw.circle(screen, RED, (targetX, targetY), 10)
    if loop >= time_delay*60:
        ball.drawDirection()
        ball.draw(speed_display)

    if angle >= 360: angle = 0
    angle += target_velocity/10 * speed_display

    screen.blit(shooter_top, (333, 75))
    screen.blit(shooter[shoot_angle - shoot_angle%5], (shooterX-95, shooterY-46))
    pg.display.update()
    clock.tick(60)
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
            exit()
