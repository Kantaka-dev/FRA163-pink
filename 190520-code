# FRA163 Pitching Machine Simulation Program
# -*- coding: utf-8 -*-
import pygame as pg
import math

pg.init()
pg.display.set_caption('FRA163 Pink-team')
pg.display.set_icon(pg.image.load('fibo_icon.jpg'))
clock = pg.time.Clock()  # set FPS=60 (error+2%)

# Final Constants ------------------------------------------------------------------------------------------------------
FONT14 = pg.font.SysFont('ocraextended', 14)
FONT16 = pg.font.SysFont('ocraextended', 16)
FONT18 = pg.font.SysFont('ocraextended', 18)
FONT20 = pg.font.SysFont('ocraextended', 20)
FONT24 = pg.font.SysFont('ocraextended', 24)
FONT30 = pg.font.SysFont('ocraextended', 30)
PURPLE = (109, 55, 140)
RED = (255, 89, 100)
GREEN = (119, 224, 36)
ORANGE = (251, 176, 59)
BLUE = (12, 239, 232)
WHITE = (255, 255, 255)
GRAY1 = (242, 242, 242)
GRAY2 = (230, 230, 230)
GRAY3 = (179, 179, 179)
GRAY4 = (153, 153, 153)
GRAY5 = (128, 128, 128)
BLACK = (0, 0, 0)
NUMBER = [46] + list(range(48, 58)) + list(range(256, 267))
input_backg = pg.image.load('input_backg.png')
simulation_backg = pg.image.load('simulation_backg.png')
shooter_top = pg.image.load('shooter_top.png')
shooter = {
    45: pg.image.load('shooter_side45.png'), 50: pg.image.load('shooter_side50.png'),
    55: pg.image.load('shooter_side55.png'), 60: pg.image.load('shooter_side60.png'),
    65: pg.image.load('shooter_side65.png'), 70: pg.image.load('shooter_side70.png'),
    75: pg.image.load('shooter_side75.png'), 80: pg.image.load('shooter_side80.png'),
    85: pg.image.load('shooter_side85.png'), 90: pg.image.load('shooter_side90.png')
}
target_side = pg.image.load('target.png')
basket_side = pg.image.load('basket_side.png')
basket_top = pg.image.load('basket_top.png')
win_x, win_y = 1024, 768
notice_txt = "Get Shooting Speed (Angle: 60 deg)"
targetX, targetY = 901, 150
shooterX, shooterY = 436, 611
radius = 74

class Box:
    def __init__(self, x, y, text=""):
        self.x = x
        self.y = y
        self.text = text
    def draw(self):
        screen.blit(FONT20.render(self.text, True, GRAY4), (self.x, self.y))

class Record(Box):
    def __init__(self, x, y):
        Box.__init__(self, x, y)
        self.record = ["", "", "", "", ""]
    def addText(self, text):
        self.record.insert(0, text)
        if len(self.record) > 5:
            self.record = self.record[0:5]
    def draw(self):
        enter = 0
        for text in self.record:
            screen.blit(FONT18.render(text, True, GRAY5), (self.x, self.y+enter))
            enter += 26
history = Record(58, 505)

class InputBox(Box):
    def __init__(self, x, y, text, text_unit, limit):
        Box.__init__(self, x, y, text)
        self.rect = pg.Rect(x-34, y-35, 304, 80)
        self.color = WHITE
        self.input_color = GRAY1
        self.txt_color = GRAY4
        self.unit = text_unit
        self.limit = limit
        self.unit_color = GRAY3
        self.value = ""
        self.value_color = BLACK
        self.active = False
        self.error = False
    def getValue(self):
        return self.value
    def resetValue(self):
        self.value = ""
    def isMouseOn(self):
        mouse_x, mouse_y = pg.mouse.get_pos()
        return True if self.x-34 < mouse_x < self.x+270 and self.y-35 < mouse_y < self.y+45 else False
    def draw(self):
        pg.draw.rect(screen, self.color, (self.x-34, self.y-35, 304, 80))
        if self.active:
            self.color, self.input_color, self.txt_color, self.unit_color = PURPLE, WHITE, WHITE, WHITE
        elif self.isMouseOn():
            self.color, self.input_color, self.txt_color, self.unit_color = GRAY1, WHITE, PURPLE, GRAY5
            pg.draw.rect(screen, PURPLE, (self.x-34, self.y-35, 9, 80))
        else:
            self.color, self.input_color, self.txt_color, self.unit_color = WHITE, GRAY1, GRAY4, GRAY3
        if self.value != "" and not self.active:
            if not self.error:
                pg.draw.rect(screen, GREEN, (self.x-2, self.y+1, 120, 32))
                pg.draw.circle(screen, GREEN, (self.x, self.y+17), 16)
                pg.draw.circle(screen, GREEN, (self.x+116, self.y+17), 16)
            else:
                pg.draw.rect(screen, RED, (self.x - 2, self.y + 1, 120, 32))
                pg.draw.circle(screen, RED, (self.x, self.y + 17), 16)
                pg.draw.circle(screen, RED, (self.x + 116, self.y + 17), 16)
                self.unit_color = RED
        pg.draw.rect(screen, self.input_color, (self.x, self.y+3, 116, 28))
        pg.draw.circle(screen, self.input_color, (self.x, self.y+17), 14)
        pg.draw.circle(screen, self.input_color, (self.x+116, self.y + 17), 14)
        screen.blit(FONT20.render(self.text, True, self.txt_color), (self.x-16, self.y-27))
        screen.blit(FONT18.render(self.unit, True, self.unit_color), (self.x+139, self.y+7))
        if self.value == "":
            if not self.active: screen.blit(FONT20.render("*", True, RED), (self.x, self.y+5))
        else:
            if not self.active and not self.limit[0] <= float(self.value) <= self.limit[1]:
                self.error = True
                self.value_color = RED
            else:
                self.error = False
                self.value_color = BLACK
            screen.blit(FONT20.render(self.value, True, self.value_color), (self.x, self.y + 5))
    def handle_event(self, event):
        if event.type == pg.MOUSEBUTTONDOWN:
            if self.rect.collidepoint(event.pos):
                self.active = True
            else:
                self.active = False
        if event.type == pg.KEYDOWN:
            print(event.key)
            if self.active:
                if event.key in NUMBER and len(self.value) < 10:
                    self.value += str(event.unicode)
                elif event.key == pg.K_BACKSPACE:
                    self.value = self.value[:-1]
distance_target = InputBox(57, 224, 'Distance to target', '(2-4)m', (2,4))
target_velocity = InputBox(57, 316, 'Target velocity', '(5-20)rpm', (5,20))
inputs = [distance_target, target_velocity]

class PushButton:
    def __init__(self):
        self.show = False
        self.active = False
    def setButton(self, x, y, text, default_color, back_color):
        self.x = x
        self.y = y
        self.rect = pg.Rect(x - 20, y, 114 + 40, 40)
        self.text = text
        self.color = GRAY1
        self.default_color = default_color
        self.txt_color = GRAY1
        self.back_color = back_color
    def isMouseOn(self):
        mouse_x, mouse_y = pg.mouse.get_pos()
        return True if self.x-20 < mouse_x < self.x+154 and self.y < mouse_y < self.y+40 else False
    def draw(self):
        if self.isMouseOn() and self.show: self.color, self.txt_color = ORANGE, ORANGE
        elif "ERROR" in notice_txt: self.color, self.txt_color = RED, RED
        elif self.show: self.color, self.txt_color = self.default_color, self.default_color
        else: self.color, self.txt_color = GRAY1, GRAY1
        pg.draw.rect(screen, self.color, (self.x-3, self.y-3, 120, 46))
        pg.draw.circle(screen, self.color, (self.x, self.y+20), 23)
        pg.draw.circle(screen, self.color, (self.x+114, self.y+20), 23)
        pg.draw.rect(screen, self.back_color, (self.x, self.y, 114, 40))
        pg.draw.circle(screen, self.back_color, (self.x, self.y+20), 20)
        pg.draw.circle(screen, self.back_color, (self.x+114, self.y+20), 20)
        screen.blit(FONT24.render(self.text, True, self.txt_color), (self.x+19, self.y+7))
    def handle_event(self, event):
        if self.show:
            if self.active:
                self.active = False if self.rect.collidepoint(event.pos) else True
            else:
                self.active = True if self.rect.collidepoint(event.pos) else False
start_btn = PushButton()
start_btn.setButton(117, 668, 'START', GREEN, WHITE)

class Choice(Box):
    def __init__(self, x, y, text):
        Box.__init__(self, x, y, text)
        self.w = 140
        self.h = 30
        self.color = GRAY2
        self.txt_color = GRAY5
    def setObject(self, objects, show=False, active=False):
        self.show = show
        self.active = active
        self.link = objects
    def getValue(self):
        return self.text
    def isMouseOn(self):
        mouse_x, mouse_y = pg.mouse.get_pos()
        return True if self.x < mouse_x < self.x+self.w and self.y < mouse_y < self.y+self.h else False
    def isMouseOff(self):
        mouse_x, mouse_y = pg.mouse.get_pos()
        return False if self.x < mouse_x < self.x+self.w and self.y < mouse_y < self.y+90 else True
    def draw(self):
        if len(self.link) == 3:
            for other in self.link:
                if other.active: self.text = other.getValue()
        if self.show == True:
            if self.isMouseOn() and pg.mouse.get_pressed()[0] == 1:
                self.active = True
                for other in self.link:
                    other.active = False
            elif self.active == True:
                self.color = PURPLE
                self.txt_color = WHITE
            elif self.isMouseOn():
                self.color = ORANGE
                self.txt_color = WHITE
            else:
                self.color = GRAY2
                self.txt_color = GRAY5
            pg.draw.rect(screen, self.color, (self.x, self.y, self.w, self.h))
            screen.blit(FONT20.render("*"+str(self.text), True, self.txt_color), (self.x+40, self.y+4))
            if len(self.link) == 3:
                pg.draw.polygon(screen, GRAY5,
                                ((self.x+110, self.y+10), (self.x+120, self.y+10), (self.x+115, self.y+20)))
speed_025 = Choice(80, 558, 0.25)
speed_050 = Choice(80, 588, 0.50)
speed_100 = Choice(80, 618, 1.00)
speed_box = Choice(80, 558, 1.00)
speed_list = [speed_box, speed_025, speed_050, speed_100]

class Basket:
    def __init__(self, posiX, posiY, phase, color=GRAY2):
        self.posiZ = posiX
        self.posiX = posiY
        self.phase = phase
        self.color = color
        self.begin = self.posiZ, self.posiX
    def setTarget(self, velocity):
        self.velocity = velocity
    def getPosition(self):
        return self.posiX
    def draw(self, angle, speed):
        angle += self.phase
        pg.draw.line(screen, self.color, (targetX, targetY), (self.posiZ, self.posiX), 5)
        screen.blit(basket_top, (int(self.posiZ)-25, int(self.posiX)-25))
        screen.blit(basket_side, (int(self.posiZ) - 25, 586))

        self.posiZ += 1.3 * self.velocity * speed * math.sin(float(angle) / 180 * math.pi)
        self.posiX += 1.3 * self.velocity * speed * math.cos(float(angle) / 180 * math.pi)
    def setBegin(self):
        self.posiZ, self.posiX = self.begin
bas1 = Basket(targetX - radius, targetY, 0, ORANGE)
bas2 = Basket(targetX, targetY + radius, 90)
bas3 = Basket(targetX + radius, targetY, 180)
bas4 = Basket(targetX, targetY - radius, 270)
baskets = [bas1, bas2, bas3, bas4]

class Ball:
    def __init__(self):
        self.direction = []
    def setShooter(self, posiX, posiY, angle, time, distance, max_height):
        frame = time*60.0
        self.posiZ = posiX
        self.posiY = posiY
        self.veloZ = 391.0 / frame
        self.veloY = -self.veloZ * math.tan(float(angle)/180*math.pi)
        self.begin = self.posiZ, self.posiY, self.veloZ, self.veloY
        self.accelY = 2 * -self.veloY / frame
        self.distance = distance
        self.max_height = max_height
    def draw(self, speed):
        pg.draw.circle(screen, ORANGE, (int(self.posiZ), int(self.posiY)), 10)
        screen.blit(FONT14.render("Y: %.2f m" %((shooterY-self.posiY)*self.distance/465), True, ORANGE),
                    (int(self.posiZ+20), int(self.posiY-17)))
        screen.blit(FONT14.render("Z: %.2f m" %((self.posiZ-shooterX)*self.distance/465), True, ORANGE),
                    (int(self.posiZ+20), int(self.posiY)))

        pg.draw.circle(screen, ORANGE, (int(self.posiZ), targetY), 10 + int((shooterY-self.posiY)*.03))
        screen.blit(FONT14.render("Z: %.2f m" %((self.posiZ-shooterX)*self.distance/465), True, ORANGE),
                    (int(self.posiZ-35), targetY+25))

        self.posiZ += self.veloZ * speed
        self.posiY += self.veloY * speed
        self.veloY += self.accelY * speed
        if self.posiZ % 15 < self.veloZ*speed:
            self.direction.append([int(self.posiZ), int(self.posiY)])
        if self.posiZ >= shooterX+195:
            screen.blit(FONT16.render("%.1f m" % (self.max_height), True, ORANGE),
                        (shooterX+170, int(shooterY - self.max_height/self.distance*465)-7))
            pg.draw.line(screen, ORANGE, (shooterX+170, int(shooterY - self.max_height/self.distance*465)+10),
                         (shooterX+220, int(shooterY - self.max_height/self.distance*465)+10), 1)
    def drawDirection(self):
        for point in self.direction:
            pg.draw.circle(screen, ORANGE, (point), 2)
            pg.draw.circle(screen, ORANGE, (point[0], targetY), 2)
    def setBegin(self):
        self.posiZ, self.posiY, self.veloZ, self.veloY = self.begin
        self.direction = []
ball = Ball()

def check(objects):
    start = False
    for obj in objects:
        if obj.getValue() == "" or obj.error or obj.active:
            start = False
            break
        start = True
    return start

def calculateAngle(distance, shoot_speed):
    check = (distance*9.81*3600) / ((shoot_speed**2) * ((0.052)**2) * ((math.pi*2) ** 2))
    if -1 <= check <= 1:
        shoot_angle = (math.asin(check)*(180/math.pi))/2
        if 45<=shoot_angle<90 :
            return shoot_angle
        if 0 <shoot_angle<45:
            return 90-shoot_angle
    else:
        return "ERROR"

def calculateVelocity(distance, shoot_angle):
    deg = shoot_angle * 2 * math.pi/180
    if 0 < shoot_angle < 90:
        target_velo = math.sqrt(distance*9.81)*60/(2*math.pi*0.052*math.sqrt(math.sin(deg)))
        return target_velo
    else:
        return "ERROR"

def delayTime(distance, target_velo, shoot_speed, shoot_angle, sequence=0):
    if 0 < shoot_angle < 90:
        t = distance/(shoot_speed*(2*math.pi/60)*0.052*math.cos(shoot_angle*math.pi/180))
        delay = 60/target_velo - t%(60/target_velo) + (15/target_velo)*sequence
        max_height = shoot_speed*(math.pi/30)*0.052*math.sin(shoot_angle*math.pi/180)*(t/2)-0.5*9.81*(t/2)**2
    return delay, t, max_height

def drawSolution(angle, speed, delay, in_air, mode_lockspeed):
    total = delay + in_air
    if mode_lockspeed:
        screen.blit(FONT20.render("Shoot Angle", True, PURPLE), (86, 280))
        screen.blit(FONT30.render("%.0f deg" % (angle), True, BLACK), (98, 303))
        screen.blit(FONT14.render("Shoot Speed: %.0f rpm" % (speed), True, GRAY5), (70, 343))
    else:
        screen.blit(FONT20.render("Shoot Speed", True, PURPLE), (86, 280))
        screen.blit(FONT30.render("%.0f rpm" % (speed), True, BLACK), (85, 303))
        screen.blit(FONT14.render("Shoot Angle: %.0f deg" % (angle), True, GRAY5), (75, 343))

    screen.blit(FONT20.render("Shoot Delay", True, PURPLE), (88, 380))
    screen.blit(FONT30.render("%.2f s" % (delay), True, BLACK), (100, 403))
    screen.blit(FONT14.render("Ball in air: %.2f s" % (in_air), True, GRAY5), (79, 442))
    screen.blit(FONT14.render("Total: %.2f s" % (total), True, GRAY5), (102, 458))

def drawTimer(loop, delay, in_air):
    n = loop/(delay*60 + in_air*60)
    screen.blit(FONT16.render("Timer:", True, GRAY2), (440, 724))
    screen.blit(FONT16.render("%.2f s" % (n*(delay+in_air)), True, GRAY2), (505 + n*300, 724))

    pg.draw.line(screen, ORANGE, (500, 733), (500 + n*300, 733), 5)
    if loop <= delay*60:
        pg.draw.line(screen, BLUE, (500, 733), (500 + n*300, 733), 5)
    else:
        pg.draw.line(screen, BLUE, (500, 733), (500 + delay/(delay+in_air)*300, 733), 5)
        screen.blit(FONT14.render("%.2f s" % (delay), True, BLUE), (450 + delay/(delay+in_air)*300, 712))
        if n == 1: screen.blit(FONT14.render("%.2f s" % (n*in_air), True, ORANGE), (750, 712))

screen = pg.display.set_mode((win_x, win_y))
while True:  # Run -----------------------------------------------------------------------------------------------------
    if not start_btn.active:
        screen.blit(input_backg, (0, 0))
        screen.blit(FONT20.render("Record", True, GRAY4), (41, 462))
        history.draw()
        if "ERROR" in notice_txt:
            screen.blit(FONT14.render(notice_txt, True, RED), (89, 720))
        else:
            screen.blit(FONT14.render(notice_txt, True, GRAY3), (41, 720))

        for input in inputs:
            input.draw()
        start_btn.show = check((distance_target, target_velocity))
        start_btn.draw()
        for event in pg.event.get():
            for input in inputs:
                input.handle_event(event)
            if event.type == pg.MOUSEBUTTONDOWN:
                start_btn.handle_event(event)
            if event.type == pg.QUIT:
                pg.quit()
                exit()
        if start_btn.active:
            target_distance = float(distance_target.value)  # meter
            target_velo = float(target_velocity.value)  # rpm
            mode_lockspeed = False  # default is False
            if mode_lockspeed:
                shoot_speed = 1000  # rpm
                if calculateAngle(target_distance, shoot_speed) == "ERROR":
                    notice_txt = "ERROR: Shooting Speed"
                    start_btn.active = False
                else:
                    shoot_angle = calculateAngle(target_distance, shoot_speed)  # degree
            else:
                shoot_angle = 60  # degree
                if calculateVelocity(target_distance, shoot_angle) == "ERROR":
                    notice_txt = "ERROR: Shooting Angle"
                    start_btn.active = False
                else:
                     shoot_speed = calculateVelocity(target_distance, shoot_angle)  # rpm
            if start_btn.active:  # check again
                time_delay, time_in_air, max_height = delayTime(target_distance,  # second second meter
                                                                target_velo,
                                                                shoot_speed,
                                                                shoot_angle)
                for basket in baskets:
                    basket.setTarget(target_velo / 10)
                ball.setShooter(shooterX, shooterY, shoot_angle, time_in_air, target_distance, max_height)
                speed_025.setObject((speed_050, speed_100))
                speed_050.setObject((speed_025, speed_100))
                speed_100.setObject((speed_025, speed_050), active=True)
                speed_box.setObject((speed_025, speed_050, speed_100), True)
                angle = 0; loop = 0; count = 0
                start_btn.setButton(94, 679, 'RESET', WHITE, (43, 31, 63))
                history.addText('Speed: %.0f Angle: %.0f' % (shoot_speed, shoot_angle))
                notice_txt = ""

    elif start_btn.active:
        screen.blit(simulation_backg, (0, 0))
        drawSolution(shoot_angle, shoot_speed, time_delay, time_in_air, mode_lockspeed)
        drawTimer(loop, time_delay, time_in_air)

        start_btn.draw()
        if speed_box.isMouseOn():
            speed_box.show = False
            for sp in speed_box.link:
                sp.show = True
        elif speed_box.isMouseOff():
            speed_box.show = True
            for sp in speed_box.link:
                sp.show = False
        for sp in speed_list:
            sp.draw()
        speed_display = speed_box.getValue()

        for basket in baskets:
            if basket.getPosition() < targetY: basket.draw(angle, speed_display)
        screen.blit(target_side, (840, 584))
        pg.draw.line(screen, GRAY2, (842, 611), (958, 611), 5)
        for basket in baskets:
            if basket.getPosition() >= targetY: basket.draw(angle, speed_display)
        pg.draw.circle(screen, RED, (targetX, targetY), 10)
        if loop >= time_delay * 60:
            ball.drawDirection()
            ball.draw(speed_display)

        if angle >= 360: angle = 0
        angle += target_velo / 10 * speed_display

        if loop > (time_delay + time_in_air)*60 or (pg.mouse.get_pressed()[0] == 1 and not speed_box.isMouseOff()):
            print ("{} ms per loop / {} ms in fact".format(pg.time.get_ticks() - count,
                                                           int(time_delay + time_in_air) * 1000))
            pg.time.delay(250 + int(50 / speed_display))
            ball.setBegin()
            for basket in baskets:
                basket.setBegin()
            angle = 0
            loop = 0
            count = pg.time.get_ticks()
        loop += speed_display
        screen.blit(shooter_top, (333, 75))
        screen.blit(shooter[shoot_angle - shoot_angle % 5], (shooterX - 95, shooterY - 46))
        for event in pg.event.get():
            if event.type == pg.MOUSEBUTTONDOWN:
                start_btn.handle_event(event)
            if event.type == pg.QUIT:
                pg.quit()
                exit()
        if not start_btn.active:
            for input in inputs:
                input.resetValue()
            start_btn.setButton(117, 668, 'START', GREEN, WHITE)

    pg.display.update()
    clock.tick(60)
