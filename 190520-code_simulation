# -*- coding: utf-8 -*-
import pygame as pg
import math
pg.init()
clock = pg.time.Clock()  # set FPS=60 (error+2%)

# Final Constants ------------------------------------------------------------------------------------------------------
FONT14 = pg.font.SysFont('ocraextended', 14)
FONT16 = pg.font.SysFont('ocraextended', 16)
FONT18 = pg.font.SysFont('ocraextended', 18)
FONT20 = pg.font.SysFont('ocraextended', 20)
FONT30 = pg.font.SysFont('ocraextended', 30)
PURPLE = (109, 55, 140)
RED = (255, 89, 100)
GREEN = (119, 224, 36)
ORANGE = (251, 176, 59)
BLUE = (12, 239, 232)
WHITE = (255, 255, 255)
GRAY1 = (242, 242, 242)
GRAY2 = (230, 230, 230)
GRAY3 = (179, 179, 179)
GRAY4 = (153, 153, 153)
GRAY5 = (128, 128, 128)
BLACK = (0, 0, 0)
simulation_backg = pg.image.load('simulation_backg.png')
shooter_top = pg.image.load('shooter_top.png')
shooter = {
    45: pg.image.load('shooter_side45.png'), 50: pg.image.load('shooter_side50.png'),
    55: pg.image.load('shooter_side55.png'), 60: pg.image.load('shooter_side60.png'),
    65: pg.image.load('shooter_side65.png'), 70: pg.image.load('shooter_side70.png'),
    75: pg.image.load('shooter_side75.png'), 80: pg.image.load('shooter_side80.png'),
    85: pg.image.load('shooter_side85.png'), 90: pg.image.load('shooter_side90.png')
}
target_side = pg.image.load('target.png')
basket_side = pg.image.load('basket_side.png')
basket_top = pg.image.load('basket_top.png')
winX, winY = 1024, 768
targetX, targetY = 901, 150
shooterX, shooterY = 436, 611
radius = 74  # radius = 57.29*size (size = 1.3)
# def getRadius(size):
#     position = 0
#     teta = 0
#     while teta<=180:
#         position += size*math.sin(float(teta) / 180 * math.pi)
#         teta += 1
#     return int(position/2)

class Basket:
    def __init__(self, posiX, posiY, phase, color=GRAY2):
        self.posiZ = posiX
        self.posiX = posiY
        self.phase = phase
        self.color = color
        self.begin = self.posiZ, self.posiX
    def setTarget(self, velocity):
        self.velocity = velocity
    def getPosition(self):
        return self.posiX
    def draw(self, angle, speed):
        angle += self.phase
        pg.draw.line(screen, self.color, (targetX, targetY), (self.posiZ, self.posiX), 5)
        screen.blit(basket_top, (int(self.posiZ)-25, int(self.posiX)-25))
        screen.blit(basket_side, (int(self.posiZ) - 25, 586))

        self.posiZ += 1.3 * self.velocity * speed * math.sin(float(angle) / 180 * math.pi)
        self.posiX += 1.3 * self.velocity * speed * math.cos(float(angle) / 180 * math.pi)
    def setBegin(self):
        self.posiZ, self.posiX = self.begin
bas1 = Basket(targetX - radius, targetY, 0, ORANGE)
bas2 = Basket(targetX, targetY + radius, 90)
bas3 = Basket(targetX + radius, targetY, 180)
bas4 = Basket(targetX, targetY - radius, 270)
baskets = [bas1, bas2, bas3, bas4]

class Ball:
    def __init__(self, posiX, posiY):
        self.posiZ = posiX
        self.posiY = posiY
        self.direction = []
    def setShooter(self, angle, time, distance, max_height):
        frame = time*60.0
        self.veloZ = 391.0 / frame
        self.veloY = -self.veloZ * math.tan(float(angle)/180*math.pi)
        self.begin = self.posiZ, self.posiY, self.veloZ, self.veloY
        self.accelY = 2 * -self.veloY / frame
        self.distance = distance
        self.max_height = max_height
    def draw(self, speed):
        pg.draw.circle(screen, ORANGE, (int(self.posiZ), int(self.posiY)), 13)
        screen.blit(FONT14.render("Y: %.2f m" %((shooterY-self.posiY)*self.distance/465), True, ORANGE),
                    (int(self.posiZ+20), int(self.posiY-17)))
        screen.blit(FONT14.render("Z: %.2f m" %((self.posiZ-shooterX)*self.distance/465), True, ORANGE),
                    (int(self.posiZ+20), int(self.posiY)))

        pg.draw.circle(screen, ORANGE, (int(self.posiZ), targetY), 13 + int((shooterY-self.posiY)*.03))
        screen.blit(FONT14.render("Z: %.2f m" %((self.posiZ-shooterX)*self.distance/465), True, ORANGE),
                    (int(self.posiZ-35), targetY+25))

        self.posiZ += self.veloZ * speed
        self.posiY += self.veloY * speed
        self.veloY += self.accelY * speed
        if self.posiZ % 10 < self.veloZ:
            self.direction.append([int(self.posiZ), int(self.posiY)])
        if self.posiZ >= shooterX+195:
            screen.blit(FONT16.render("%.1f m" % (self.max_height), True, ORANGE),
                        (shooterX+170, int(shooterY - self.max_height/self.distance*465)-22))
            pg.draw.line(screen, ORANGE, (shooterX+170, int(shooterY - self.max_height/self.distance*465)-5),
                         (shooterX+220, int(shooterY - self.max_height/self.distance*465)-5), 1)
    def drawDirection(self):
        for point in self.direction:
            pg.draw.circle(screen, ORANGE, (point), 2)
            pg.draw.circle(screen, ORANGE, (point[0], targetY), 2)
    def setBegin(self):
        self.posiZ, self.posiY, self.veloZ, self.veloY = self.begin
        self.direction = []
ball = Ball(shooterX, shooterY)

class Choice:
    def __init__(self, x, y, text):
        self.x = x
        self.y = y
        self.w = 140
        self.h = 30
        self.color = GRAY2
        self.text = text
        self.txt_color = GRAY5
    def setObject(self, objects, show=False, active=False):
        self.show = show
        self.active = active
        self.link = objects
    def getValue(self):
        return self.text
    def isMouseOn(self):
        mouse_x, mouse_y = pg.mouse.get_pos()
        return True if self.x < mouse_x < self.x+self.w and self.y < mouse_y < self.y+self.h else False
    def isMouseOff(self):
        mouse_x, mouse_y = pg.mouse.get_pos()
        return False if self.x < mouse_x < self.x+self.w and self.y < mouse_y < self.y+90 else True
    def draw(self):
        if len(self.link) == 3:
            for other in self.link:
                if other.active: self.text = other.getValue()
        if self.show == True:
            if self.isMouseOn() and pg.mouse.get_pressed()[0] == 1:
                self.active = True
                for other in self.link:
                    other.active = False
            elif self.active == True:
                self.color = PURPLE
                self.txt_color = WHITE
            elif self.isMouseOn():
                self.color = ORANGE
                self.txt_color = WHITE
            else:
                self.color = GRAY2
                self.txt_color = GRAY5
            pg.draw.rect(screen, self.color, (self.x, self.y, self.w, self.h))
            screen.blit(FONT20.render("*"+str(self.text), True, self.txt_color), (self.x+40, self.y+4))
speed_025 = Choice(80, 558, 0.25)
speed_050 = Choice(80, 588, 0.50)
speed_100 = Choice(80, 618, 1.00)
speed_box = Choice(80, 558, 1.00)
speed_list = [speed_box, speed_025, speed_050, speed_100]

def drawSolution(angle, speed, delay, total, mode_lockspeed):
    if mode_lockspeed:
        screen.blit(FONT20.render("Shoot Angle", True, PURPLE), (86, 285))
        screen.blit(FONT30.render("{} deg".format(angle), True, BLACK), (98, 308))
        screen.blit(FONT14.render("Shoot Speed: {} rpm".format(speed), True, GRAY5), (70, 348))
    else:
        screen.blit(FONT20.render("Shoot Speed", True, PURPLE), (86, 285))
        screen.blit(FONT30.render("{} rpm".format(speed), True, BLACK), (85, 308))
        screen.blit(FONT14.render("Shoot Angle: {} deg".format(angle), True, GRAY5), (75, 348))

    screen.blit(FONT20.render("Shoot Delay", True, PURPLE), (88, 390))
    screen.blit(FONT30.render("%.2f s" % (delay), True, BLACK), (100, 413))
    screen.blit(FONT14.render("Total: %.2f s" % (total), True, GRAY5), (102, 453))

def drawTimer(loop, delay, in_air):
    n = loop/(delay*60 + in_air*60)
    screen.blit(FONT16.render("Timer:", True, GRAY2), (440, 724))
    screen.blit(FONT16.render("%.2f s" % (n*(delay+in_air)), True, GRAY2), (505 + n*300, 724))

    pg.draw.line(screen, ORANGE, (500, 733), (500 + n*300, 733), 5)
    if loop <= delay*60:
        pg.draw.line(screen, BLUE, (500, 733), (500 + n*300, 733), 5)
    else:
        pg.draw.line(screen, BLUE, (500, 733), (500 + delay/(delay+in_air)*300, 733), 5)
        screen.blit(FONT14.render("%.2f s" % (delay), True, BLUE), (450 + delay/(delay+in_air)*300, 712))
        if n == 1: screen.blit(FONT14.render("%.2f s" % (n*in_air), True, ORANGE), (750, 712))

# Input ----------------------------------------------------------------------------------------------------------------
target_distance = 2  # meter
target_velocity = 20.0  # rpm
shoot_angle = 60  # degree
shoot_speed = 1000  # rpm
time_delay = 1.0  # second
time_in_air = 2.0   # second
max_height = 0.8  # meter
mode = False

for basket in baskets:
    basket.setTarget(target_velocity/10)
ball.setShooter(shoot_angle, time_in_air, target_distance, max_height)
speed_025.setObject((speed_050, speed_100))
speed_050.setObject((speed_025, speed_100))
speed_100.setObject((speed_025, speed_050), active=True)
speed_box.setObject((speed_025, speed_050, speed_100), True)
angle = 0 ; loop = 0 ; count = 0

screen = pg.display.set_mode((winX, winY))
while True:  # Run -----------------------------------------------------------------------------------------------------
    screen.blit(simulation_backg, (0, 0))
    drawSolution(shoot_angle, shoot_speed, time_delay, time_delay+time_in_air, mode)
    drawTimer(loop, time_delay, time_in_air)

    if speed_box.isMouseOn():
        speed_box.show = False
        for sp in speed_box.link:
            sp.show = True
    elif speed_box.isMouseOff():
        speed_box.show = True
        for sp in speed_box.link:
            sp.show = False
    for sp in speed_list:
        sp.draw()
    speed_display = speed_box.getValue()

    for basket in baskets:
        if basket.getPosition() < targetY: basket.draw(angle, speed_display)
    screen.blit(target_side, (840, 584))
    pg.draw.line(screen, GRAY2, (842, 611), (958, 611), 5)
    for basket in baskets:
        if basket.getPosition() >= targetY: basket.draw(angle, speed_display)
    pg.draw.circle(screen, RED, (targetX, targetY), 10)
    if loop >= time_delay*60:
        ball.drawDirection()
        ball.draw(speed_display)

    if angle >= 360: angle = 0
    angle += target_velocity/10 * speed_display

    if loop > (time_delay+time_in_air)*60 or pg.mouse.get_pressed()[0] == 1:
        print ("{} ms per loop / {} ms in fact".format(pg.time.get_ticks()-count, int(time_delay+time_in_air)*1000))
        pg.time.delay(250 + int(50/speed_display))
        ball.setBegin()
        for basket in baskets:
            basket.setBegin()
        angle = 0
        loop = 0
        count = pg.time.get_ticks()
    loop += speed_display
    screen.blit(shooter_top, (333, 75))
    screen.blit(shooter[shoot_angle - shoot_angle%5], (shooterX-95, shooterY-46))
    pg.display.update()
    clock.tick(60)
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
            exit()
