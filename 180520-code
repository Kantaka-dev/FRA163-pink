# FRA163 Pitching Machine Simulation Program
import pygame as pg
import math
pg.init()
clock = pg.time.Clock()  # set FPS=60 (error+2%)

FONT14 = pg.font.SysFont('ocraextended', 14)
FONT16 = pg.font.SysFont('ocraextended', 16)
FONT18 = pg.font.SysFont('ocraextended', 18)
FONT20 = pg.font.SysFont('ocraextended', 20)
PURPLE = (109, 55, 140)
RED = (255, 89, 100)
GREEN = (119, 224, 36)
ORANGE = (251, 176, 59)
BLUE = (12, 239, 232)
WHITE = (255, 255, 255)
GRAY1 = (242, 242, 242)
GRAY2 = (230, 230, 230)
GRAY3 = (179, 179, 179)
GRAY4 = (153, 153, 153)
GRAY5 = (128, 128, 128)
BLACK = (0, 0, 0)

input_backg = pg.image.load('input_backg.png')
simulation_backg = pg.image.load('simulation_backg.png')
shooter_top = pg.image.load('shooter_top.png')
shooter = {
    45: pg.image.load('shooter_side45.png'), 50: pg.image.load('shooter_side50.png'),
    55: pg.image.load('shooter_side55.png'), 60: pg.image.load('shooter_side60.png'),
    65: pg.image.load('shooter_side65.png'), 70: pg.image.load('shooter_side70.png'),
    75: pg.image.load('shooter_side75.png'), 80: pg.image.load('shooter_side80.png'),
    85: pg.image.load('shooter_side85.png'), 90: pg.image.load('shooter_side90.png')
}
target_side = pg.image.load('target.png')
basket_side = pg.image.load('basket_side.png')
basket_top = pg.image.load('basket_top.png')

targetX, targetY = 901, 150
shooterX, shooterY = 436, 611
radius = 74

class Basket:
    def __init__(self, posiX, posiY, phase, color=GRAY2):
        self.posiZ = posiX
        self.posiX = posiY
        self.phase = phase
        self.color = color
        self.begin = self.posiZ, self.posiX
    def setTarget(self, velocity):
        self.velocity = velocity
    def draw(self, angle, speed):
        angle += self.phase
        pg.draw.line(screen, self.color, (targetX, targetY), (self.posiZ, self.posiX), 5)
        screen.blit(basket_top, (int(self.posiZ)-25, int(self.posiX)-25))
        if self.posiX >= targetY*0.6:
            pg.draw.line(screen, self.color, (targetX, shooterY), (self.posiZ, shooterY), 5)
            screen.blit(basket_side, (int(self.posiZ) - 25, 586))

        self.posiZ += 1.3 * self.velocity * speed * math.sin(float(angle) / 180 * math.pi)
        self.posiX += 1.3 * self.velocity * speed * math.cos(float(angle) / 180 * math.pi)
    def setBegin(self):
        self.posiZ, self.posiX = self.begin
bas1 = Basket(targetX - radius, targetY, 0, ORANGE)
bas2 = Basket(targetX, targetY + radius, 90)
bas3 = Basket(targetX + radius, targetY, 180)
bas4 = Basket(targetX, targetY - radius, 270)
baskets = [bas1, bas2, bas3, bas4]

class Ball:
    def __init__(self, posiX, posiY):
        self.posiZ = posiX
        self.posiY = posiY
        self.direction = []
    def setShooter(self, angle, time, distance):
        frame = time*60.0
        self.veloZ = 391.0 / frame
        self.veloY = -self.veloZ * math.tan(float(angle)/180*math.pi)
        self.begin = self.posiZ, self.posiY, self.veloZ, self.veloY
        self.accelY = 2 * -self.veloY / frame
        self.distance = distance
    def draw(self, speed):
        pg.draw.circle(screen, ORANGE, (int(self.posiZ), int(self.posiY)), 13)
        screen.blit(FONT14.render("Y: %.2f m" %((shooterY-self.posiY)*self.distance/465), True, ORANGE),
                    (int(self.posiZ+20), int(self.posiY-17)))
        screen.blit(FONT14.render("Z: %.2f m" %((self.posiZ-shooterX)*self.distance/465), True, ORANGE),
                    (int(self.posiZ+20), int(self.posiY)))

        pg.draw.circle(screen, ORANGE, (int(self.posiZ), targetY), 13 + int((shooterY-self.posiY)*.03))
        screen.blit(FONT14.render("Z: %.2f m" %((self.posiZ-shooterX)*self.distance/465), True, ORANGE),
                    (int(self.posiZ-35), targetY+25))

        self.posiZ += self.veloZ * speed
        self.posiY += self.veloY * speed
        self.veloY += self.accelY * speed
        if self.posiZ % 10 < self.veloZ:
            self.direction.append([int(self.posiZ), int(self.posiY)])
    def drawDirection(self):
        for point in self.direction:
            pg.draw.circle(screen, ORANGE, (point), 2)
            pg.draw.circle(screen, ORANGE, (point[0], targetY), 2)
    def setBegin(self):
        self.posiZ, self.posiY, self.veloZ, self.veloY = self.begin
        self.direction = []
ball = Ball(shooterX, shooterY)

def drawSolution(angle, speed, delay, total, mode_lockspeed):
    if mode_lockspeed:
        screen.blit(FONT20.render("Shoot Angle: {} deg".format(angle), True, BLACK), (30, 340))
        screen.blit(FONT14.render("Shoot Speed: {} rpm".format(speed), True, GRAY5), (30, 370))
    else:
        screen.blit(FONT20.render("Shoot Speed: {} rpm".format(speed), True, BLACK), (30, 340))
        screen.blit(FONT14.render("Shoot Angle: {} deg".format(angle), True, GRAY5), (30, 370))

    screen.blit(FONT20.render("Shoot Delay: %i ms" %(delay*1000), True, BLACK), (30, 410))
    screen.blit(FONT14.render("Total: %i ms" %(total*1000), True, GRAY5), (30, 440))

def drawTimer(loop, delay, in_air):
    n = loop/(delay*60 + in_air*60)
    screen.blit(FONT16.render("Timer:", True, GRAY2), (440, 724))
    screen.blit(FONT16.render("%.0f ms" %(n*(delay+in_air)*1000), True, GRAY2), (505 + n*300, 724))

    pg.draw.line(screen, ORANGE, (500, 733), (500 + n*300, 733), 5)
    if loop <= delay*60:
        pg.draw.line(screen, BLUE, (500, 733), (500 + n*300, 733), 5)
    else:
        pg.draw.line(screen, BLUE, (500, 733), (500 + delay/(delay+in_air)*300, 733), 5)
        screen.blit(FONT14.render("%.0f ms" %(delay*1000), True, BLUE), (445 + delay/(delay+in_air)*300, 712))
        if n == 1: screen.blit(FONT14.render("%.0f ms" %(n*in_air*1000), True, ORANGE), (745, 712))

def CalculateAngle(x,z): #x=distance y=target velocity z=shooter Speed
    check = (x * 9.81 * 3600) / ((z ** 2) * ((0.052) ** 2) * ((math.pi * 2) ** 2))
    if -1 <=check<= 1 :
        result = (math.asin(check)*(180/math.pi))/2
        if 45<=result<90 :
            return result
        if 0 <result<45:
            return 90-result
    else:
        return "ERROR"
#print(CalculateAngle(3,1500))

def CalculateVelocity(x,a): #x=distance y=target velocity a=angle
    deg = (a) * 2 * (math.pi / 180)
    if 0<a<90 :
        result = (math.sqrt(x*9.81)*60)/(2*math.pi*0.052*math.sqrt(math.sin(deg)))
        return result
    else:
        return "ERROR"
#print(CalculateVelocity(3,33))

def DelayTime(x,y,z,a,n): #x=distance y=target velocity z=shooter Speed a=angle n=sequence
    if 0 < a < 90:
        t = x/((z)*((2*math.pi)/60)*0.052*math.cos(a* (math.pi / 180)))
        dt=t%(60/y)
        det = (60/y)-dt+(15/y)*n
    return det
#print(DelayTime(3,10,1500,33,1))

def Overall(x,y,z,a,n):
    if 0 < a < 90:
        an = a* (math.pi / 180)
        u = (z) * ((2 * math.pi) / 60)*0.052
        t = x / (u *math.cos(an))
        sy = u*math.sin(an)*(t/2)-0.5*9.81*(t/2)**2
        #print(u*math.sin(an)*(t/2),0.5*9.81*(t/2)**2,(t/2)**2)
        return y,x,CalculateVelocity(x,a),CalculateAngle(x,z),sy,DelayTime(x,y,z,a,n),t
print(Overall(3,10,1500,70,1))
Vt,Sx,Vx,A,Sy,dT,T = Overall(3,10,1500,33,1)

win_x, win_y = 1024, 768
input_step = True
simulation_step = False
screen = pg.display.set_mode((win_x, win_y))
angle = 0 ; loop = 0 ; count = 0
while True:
    if input_step:
        screen.blit(input_backg, (0, 0))
        if start_btn:
            # target_distance = 2  # meter
            # target_velocity = 20.0  # rpm
            # shoot_angle = 60  # degree
            # shoot_speed = 1000  # rpm
            # time_delay = 1.0  # second
            # time_in_air = 2.0   # second
            # speed_display = 1.0
            # mode = True
            # for basket in baskets:
            #     basket.setTarget(target_velocity/10)
            # ball.setShooter(shoot_angle, time_in_air, target_distance)
    elif simulation_step:
        screen.blit(simulation_backg, (0, 0))
        screen.blit(target_side, (851, 606))
        if loop >= (time_delay+time_in_air)*60:
            print ("{} ms per loop / {} ms in fact".format(pg.time.get_ticks()-count, int(time_delay+time_in_air)*1000))
            pg.time.delay(300)
            ball.setBegin()
            for basket in baskets:
                basket.setBegin()
            angle = 0
            loop = 0
            count = pg.time.get_ticks()
        loop += speed_display
        
        drawSolution(shoot_angle, shoot_speed, time_delay, time_delay+time_in_air, mode)
        drawTimer(loop, time_delay, time_in_air)
        
        for basket in baskets:
            basket.draw(angle, speed_display)
        pg.draw.circle(screen, RED, (targetX, targetY), 10)
        if loop >= time_delay*60:
            ball.drawDirection()
            ball.draw(speed_display)
        
        if angle >= 360: angle = 0
        angle += target_velocity/10 * speed_display
        
        screen.blit(shooter_top, (333, 75))
        screen.blit(shooter[shoot_angle - shoot_angle%5], (shooterX-95, shooterY-46))
    pg.display.update()
    clock.tick(60)
    for event in pg.event.get():
        if input_step:
            pass
        elif simulation_step:
            pass
        if event.type == pg.QUIT:
            pg.quit()
            exit()
